import org.gradle.api.tasks.testing.logging.TestLogEvent
import java.nio.file.Files

plugins {
    // Apply the java plugin to add support for Java
    id 'java'

    // Apply the application plugin to add support for building a CLI application
    id 'application'
    
    id 'jacoco'
}

repositories {
    // Use jcenter for resolving dependencies.
    // You can declare any Maven/Ivy/file repository here.
    jcenter()
}

dependencies {
    // Use Hamcrest for assertions
    testImplementation 'org.hamcrest:hamcrest-library:2.1'

    // Use JUnit Jupiter API for testing.
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.4.2'

    // Use JUnit Jupiter Engine for testing.
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.4.2'
}

application {
    // Define the main class for the application
    mainClassName = 'App'
}

test {
    useJUnitPlatform()
    // Do not fail builds because of failing tests
    ignoreFailures true

    testLogging {
        // Always show all tests, even passed ones; also, show stdout/stderr, helps for debugging
        events TestLogEvent.FAILED, TestLogEvent.PASSED, TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT, TestLogEvent.STANDARD_ERROR
        // Always run all tests
        outputs.upToDateWhen { false }
    }

    // If a crash happens during execution, tell the user about it
    afterSuite { desc, result ->
        if (result.exception) {
            if (result.exception.message.contains('Could not complete execution')) {
                println('A crash happened while executing unit tests:')
                result.exception.cause.printStackTrace()
            } else {
                println('An unknown error occurred while executing unit tests:')
                result.exception.printStackTrace()
            }
        }
    }
}

jacocoTestReport {
    // XML report, for scripting purposes
    reports.xml.enabled true
    // HTML report, for human purposes
    reports.html.destination file("${buildDir}/reports/coverage")
}

build {
    // Always generate coverage
    dependsOn jacocoTestReport
    // Add some help to JaCoCo reports
    doLast {
        def msg = '''SwEng help:
                     <ul>
                       <li>JaCoCo calls statements "instructions"</li>
                       <li>JaCoCo does not compute path coverage, because it is usually not helpful in real code</li>
                       <li>The column 'Cxty' is the <a target="_blank" href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">cyclomatic complexity</a></li>
                     </ul>'''

        fileTree("${buildDir}/reports/coverage").include('**/*.html').each { f ->
            Files.writeString(f.toPath(), Files.readString(f.toPath()).replace('</h1>', "</h1><p>${msg}</p>"))
        }
    }
    // Tell the user about the report file
    doLast {
        println 'You can view the code coverage report in build/reports/coverage/index.html'
    }
}
